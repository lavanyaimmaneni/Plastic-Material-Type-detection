# -*- coding: utf-8 -*-
"""code_for_video_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AGEUtBPnkZGmpUWcMQBAAsG4FtfGqAX_
"""

# Step 1: Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Step 2: Install required libraries
!pip install ultralytics opencv-python-headless

# Step 3: Import required libraries
from ultralytics import YOLO
import cv2
import numpy as np
from IPython.display import display, Javascript, Image
from google.colab.output import eval_js
from base64 import b64decode
import os

# Step 4: Set paths
model_path = '/content/drive/MyDrive/yolo1/plastic_detection_results/weights/best.pt'
output_dir = '/content/drive/MyDrive/yolo1/plastic_detection_results/webcam_inference_results'
os.makedirs(output_dir, exist_ok=True)

# Step 5: Load the model
model = YOLO(model_path)

# Step 6: JavaScript to access webcam
def take_photo(filename='photo.jpg', quality=0.8):
    js = Javascript('''
        async function takePhoto(quality) {
            const div = document.createElement('div');
            const capture = document.createElement('button');
            capture.textContent = 'Capture Frame';
            div.appendChild(capture);

            const video = document.createElement('video');
            video.style.display = 'block';
            const stream = await navigator.mediaDevices.getUserMedia({video: true});

            document.body.appendChild(div);
            div.appendChild(video);
            video.srcObject = stream;
            await video.play();

            // Resize the output to fit the video element.
            google.colab.output.setIframeHeight(document.documentElement.scrollHeight, true);

            // Wait for Capture to be clicked
            let image_data;
            capture.onclick = () => {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);
                image_data = canvas.toDataURL('image/jpeg', quality);
                stream.getTracks().forEach(track => track.stop());
                div.remove();
            };
            return new Promise(resolve => {
                const check = setInterval(() => {
                    if (image_data) {
                        clearInterval(check);
                        resolve(image_data);
                    }
                }, 100);
            });
        }
        ''')
    display(js)
    data = eval_js('takePhoto({})'.format(quality))
    binary = b64decode(data.split(',')[1])
    with open(filename, 'wb') as f:
        f.write(binary)
    return filename

# Step 7: Function to process and predict
def predict_from_webcam():
    frame_count = 0
    print("Click the 'Capture Frame' button to capture and process a frame. Stop the cell to end.")
    while True:
        try:
            # Capture frame from webcam
            img_path = take_photo(f'frame_{frame_count:06d}.jpg')
            print(f"Captured frame {frame_count} saved as {img_path}")

            # Read the image with OpenCV
            img = cv2.imread(img_path)
            if img is None:
                print("Failed to load image. Retrying...")
                continue

            # Run YOLOv8 prediction
            results = model.predict(
                source=img,
                conf=0.25,        # Confidence threshold
                iou=0.45,         # IoU threshold
                save=True,        # Save results
                save_txt=True,    # Save predictions as .txt
                project=output_dir,
                name='webcam_predictions',
                exist_ok=True
            )
            print(f"Inference completed for frame {frame_count}")

            # Get the annotated image path
            annotated_image_path = os.path.join(output_dir, 'webcam_predictions', f"frame_{frame_count:06d}.jpg")

            # Display the annotated image
            if os.path.exists(annotated_image_path):
                display(Image(filename=annotated_image_path))
            else:
                print(f"Annotated image not found at {annotated_image_path}")

            # Remove the temporary input image
            os.remove(img_path)

            frame_count += 1

        except Exception as e:
            print(f"An error occurred: {e}")
            break

# Step 8: Run the prediction loop
predict_from_webcam()